/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/stegano@1.0.0/lib/encryptor.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
"use strict";var __awaiter=this&&this.__awaiter||function(t,i,e,a){return new(e||(e=Promise))((function(r,n){function o(t){try{p(a.next(t))}catch(t){n(t)}}function s(t){try{p(a.throw(t))}catch(t){n(t)}}function p(t){var i;t.done?r(t.value):(i=t.value,i instanceof e?i:new e((function(t){t(i)}))).then(o,s)}p((a=a.apply(t,i||[])).next())}))},__importDefault=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(exports,"__esModule",{value:!0}),exports.Encryptor=void 0;const isInteger_1=__importDefault(require("lodash/isInteger")),bit_stuffing_1=require("./bit-stuffing"),buffer_to_bit_coverter_1=require("./buffer-to-bit-coverter");class Encryptor{constructor(){this.bitStuffing=new bit_stuffing_1.BitStuffing}encrypt(t,i,e){const a=t.clone(),r=Buffer.from(i,"utf-8"),n=Buffer.from([...this.bitStuffing.escape(r)]),o=buffer_to_bit_coverter_1.convertBufferToBits(n),s=3*(a.bitmap.width*a.bitmap.height-1)*e;if(s<o.length)throw new Error(`Image too small. Capacity (with depth=${e}) is ${s} bits. Secret requires ${o.length} bits`);const p=a.scanIterator(0,0,a.bitmap.width,a.bitmap.height);for(const{x:t,y:i,idx:r}of p){if(0===t&&0===i){this.setDepth(a,r,e);continue}const n=o.splice(0,e).join("").padEnd(e,"0"),s=parseInt(n,2);a.bitmap.data[r+0]=this.applyRightMostBits(a.bitmap.data[r+0],e,s);const p=o.splice(0,e).join("").padEnd(e,"0"),f=parseInt(p,2);a.bitmap.data[r+1]=this.applyRightMostBits(a.bitmap.data[r+1],e,f);const c=o.splice(0,e).join("").padEnd(e,"0"),u=parseInt(c,2);if(a.bitmap.data[r+2]=this.applyRightMostBits(a.bitmap.data[r+2],e,u),0===o.length)break}return a}decrypt(t){const i=t.scanIterator(0,0,t.bitmap.width,t.bitmap.height);let e,a="",r=Buffer.from([]),n=!1;for(const{x:o,y:s,idx:p}of i){if(0===o&&0===s){e=this.getDepth(t,p);continue}a+=t.bitmap.data[p+0].toString(2).padStart(8,"0").slice(-e);a+=t.bitmap.data[p+1].toString(2).padStart(8,"0").slice(-e);for(a+=t.bitmap.data[p+2].toString(2).padStart(8,"0").slice(-e);a.length>=8;){const t=a.split(""),i=t.splice(0,8);a=t.join("");const e=parseInt(i.join(""),2);if(r=Buffer.concat([r,Buffer.from([e])]),e===bit_stuffing_1.BitStuffing.FE){n=!0;break}}if(n)break}return Buffer.from([...this.bitStuffing.unescape(r)]).toString("utf-8")}setDepth(t,i=0,e){return __awaiter(this,void 0,void 0,(function*(){if(!isInteger_1.default(e)||e<1||e>7)throw new Error("Depth should be an integer from 1 to 7");const a=(e>>2)%2,r=(e>>1)%2,n=(e>>0)%2;t.bitmap.data[i+0]=this.applyRightMostBits(t.bitmap.data[i+0],1,a),t.bitmap.data[i+1]=this.applyRightMostBits(t.bitmap.data[i+1],1,r),t.bitmap.data[i+2]=this.applyRightMostBits(t.bitmap.data[i+2],1,n)}))}applyRightMostBits(t,i,e){return t-t%Math.pow(2,i)+e%Math.pow(2,i)}getDepth(t,i){const e=t.bitmap.data[i+0],a=t.bitmap.data[i+1],r=t.bitmap.data[i+2];return parseInt(`${e%2}${a%2}${r%2}`,2)}}exports.Encryptor=Encryptor;
//# sourceMappingURL=/sm/20c4a11b21117ee16b27012f177d107c9d17fd67de69b0f7e721ec9b1819f49d.map