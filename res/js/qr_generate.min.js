

function generateKey() {
    const key = CryptoJS.lib.WordArray.random(32).toString(CryptoJS.enc.Hex);
    document.getElementById("encryption-key").value = key;
    return key;
}


function encryptText(text, key) {
    return CryptoJS.AES.encrypt(text, key).toString();
}


function decryptText(ciphertext, key) {
    try {
        const bytes = CryptoJS.AES.decrypt(ciphertext, key);
        return bytes.toString(CryptoJS.enc.Utf8);
    } catch (e) {
        return null; // Если ключ неверный
    }
}

function copyKey() {
    const keyInput = document.getElementById("encryption-key");
    keyInput.select();
    document.execCommand("copy");
    alert("Ключ скопирован!");
}

let app1;
!(function (e) {
    function generateQRCode() {
        const isEncryptionEnabled = document.getElementById("encrypt-toggle").checked;
        let inputText = document.getElementById("input-text").value;

        if (isEncryptionEnabled) {
            const encryptionKey = generateKey();
            inputText = encryptText(inputText, encryptionKey);
            document.getElementById("encryption-key-row").style.display = "table-row";
        } else {
            document.getElementById("encryption-key-row").style.display = "none";
        }

        const qrCanvas = document.getElementById("qrcode-canvas");
        qrCanvas.style.display = "none";
        
        const errorCorrectionLevel = document.getElementById("errcorlvl-medium").checked
            ? qrcodegen.QrCode.Ecc.MEDIUM
            : document.getElementById("errcorlvl-quartile").checked
                ? qrcodegen.QrCode.Ecc.QUARTILE
                : document.getElementById("errcorlvl-high").checked
                    ? qrcodegen.QrCode.Ecc.HIGH
                    : qrcodegen.QrCode.Ecc.LOW;


        const qrSegments = qrcodegen.QrSegment.makeSegments(inputText);
        const minVersion = parseInt(document.getElementById("force-min-version").value, 10);
        const maskPattern = parseInt(document.getElementById("force-mask-pattern").value, 10);
        const qrSize = document.getElementById("force-size").value;
       
        const qrCode = qrcodegen.QrCode.encodeSegments(qrSegments, errorCorrectionLevel, minVersion, 40, maskPattern, 0);
        const lightColor = document.getElementById("light-color-input").value;
        const darkColor = document.getElementById("dark-color-input").value;
        const gradientEndColor = document.getElementById("s_light-color-input").value;

        {
            let moduleSize = qrSize;

            (function (qrCode, moduleSize, border, lightColor, darkColor, gradientEndColor, canvas)  {
                if (moduleSize <= 0 || border < 0) throw new RangeError("Value out of range");
                const canvasSize = (qrCode.size + 2 * border) * moduleSize;
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const scale = 4;
                canvas.width = canvasSize * scale;
                canvas.height = canvasSize * scale;
                canvas.style.width = canvasSize + "px";
                canvas.style.height = canvasSize + "px";

                const ctx = canvas.getContext("2d");
                ctx.scale(scale, scale);
                const imageInput = document.getElementById("qr-image-input");
                const shouldRemoveBackground = document.getElementById("remove-background").checked;

                const centerImageSize = Math.floor(canvasSize / 3);
                const centerX = (canvasSize - centerImageSize) / 2;
                const centerY = (canvasSize - centerImageSize) / 2;

                // Создаем градиент
                const gradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
                gradient.addColorStop(0, darkColor);
                gradient.addColorStop(1, gradientEndColor);

                const moduleStyle = document.getElementById('module-style').value;

    // Функция для рисования разных форм
    function drawModule(ctx, x, y, size, style) {
        ctx.beginPath();
        switch(style) {
            case 'circle':
                ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI*2);
                break;
            
            
            default: // square
                ctx.rect(x, y, size, size);
        }
        ctx.fill();
    }

                // Рисуем QR-код
                for (let y = -border; y < qrCode.size + border; y++) {
                    for (let x = -border; x < qrCode.size + border; x++) {
                        const moduleX = (x + border) * moduleSize;
                        const moduleY = (y + border) * moduleSize;
            
                        ctx.fillStyle = qrCode.getModule(x, y) ? gradient : lightColor;
                        drawModule(ctx, moduleX, moduleY, moduleSize, moduleStyle);
                    }
                }

                if (shouldRemoveBackground && imageInput.files.length > 0) {
                    const bgImage = new Image();
                    bgImage.src = "res/picture/backgroung.png";
                    bgImage.onload = function () {
                        ctx.drawImage(bgImage, centerX, centerY, centerImageSize, centerImageSize);

                        if (imageInput.files.length > 0) {
                            const centerImage = new Image();
                            centerImage.src = URL.createObjectURL(imageInput.files[0]);
                            centerImage.onload = function () {
                                ctx.drawImage(centerImage, centerX, centerY, centerImageSize, centerImageSize);
                            };
                        }
                    };
                } else if (imageInput.files.length > 0) {
                    const centerImage = new Image();
                    centerImage.src = URL.createObjectURL(imageInput.files[0]);
                    centerImage.onload = function () {
                        ctx.drawImage(centerImage, centerX, centerY, centerImageSize, centerImageSize);
                    };
                }
            })(qrCode, moduleSize, 2, lightColor, darkColor, gradientEndColor, qrCanvas);

            qrCanvas.style.removeProperty("display");
        }
    }

    function getElementById(id) {
        const element = document.getElementById(id);
        if (element instanceof HTMLElement) return element;
    }

    function getInputElementById(id) {
        const element = getElementById(id);
        if (element instanceof HTMLInputElement) return element;
    }

    // Привязываем генерацию QR-кода к кнопке
    document.getElementById("generateButton").addEventListener("click", function (e) {
        e.preventDefault();
        generateQRCode();
    });


    ((app1 || (app1 = {})).handleVersionMinMax = function (e) {
        const n = o("force-min-version");
        let r = parseInt(n.value, 10),
            c = parseInt((40).value, 10);
        (r = Math.max(
            Math.min(r, qrcodegen.QrCode.MAX_VERSION),
            qrcodegen.QrCode.MIN_VERSION
        )),
            (c = Math.max(
                Math.min(c, qrcodegen.QrCode.MAX_VERSION),
                qrcodegen.QrCode.MIN_VERSION
            )),
            "min" == e && r > c ? (c = r) : "max" == e && c < r && (r = c),
            (n.value = r.toString()),
            c.toString(),
            t();
    }),
        (function initEventListeners() {//При изменение значений элементов range - меняются и значения input
            let inputs = document.querySelectorAll("input[type=number], input[type=text], textarea");
            for (let input of inputs) {
                if (!input.id.startsWith("version-")) {
                    input.oninput = generateQRCode;
                }
            }
            generateQRCode();
        
        const minVersionInput = document.getElementById("force-min-version");
        const maskPatternInput = document.getElementById("force-mask-pattern");
        const sizeInput = document.getElementById("force-size");
        const minVersionRange = document.getElementById("customRange3");
        const maskPatternRange = document.getElementById("customRange4");
        const sizeRange = document.getElementById("customRange5");

        function handleRangeInput(e) {
            const target = e.target;
            if (target === minVersionRange) {
                minVersionInput.value = target.value;
            } else if (target === maskPatternRange) {
                maskPatternInput.value = target.value;
            }
            else if (target === sizeRange) {
                sizeInput.value = target.value;
            }
            generateQRCode();
        }

            minVersionRange.addEventListener("input", handleRangeInput);
        maskPatternRange.addEventListener("input", handleRangeInput);
        sizeInput.addEventListener("input", handleRangeInput);
        sizeRange.addEventListener("input", handleRangeInput);
                document.querySelector('button[type="submit"]').addEventListener("click", function (e) {
            e.preventDefault();
            generateQRCode();
                    });
        })();
})();


function getChatId() {
    // Получаем данные пользователя
    const initData = new URLSearchParams(Telegram.WebApp.initData);

    // Извлекаем user.id
    const user = JSON.parse(initData.get('user'));
    return user?.id;
}


function sendImageToTelegram(dataURL) {
    const token = '7650373965:AAFUdBo-eMpIVIn_wXngV7TUs7lWtt1Lqq8';
    const chatId = getChatId();

    if (!chatId) {
        //alert('Ошибка: не удалось получить chat_id пользователя.');
        const canvas = document.getElementById('qrcode-canvas');
        const dataURL = canvas.toDataURL('image/png');

        // Создаем временную ссылку
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = document.getElementById('input-text').value + '.png'; // Имя файла при скачивании

        // Программно кликаем по ссылке, чтобы инициировать скачивание
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link); // Удаляем ссылку после скачивания
        return;
    }

    // Преобразуем data URL в Blob
    fetch(dataURL)
        .then(res => res.blob())
        .then(blob => {
            const formData = new FormData();
            formData.append('photo', blob, 'qr_code.jpg');

            return fetch(`https://api.telegram.org/bot${token}/sendPhoto?chat_id=${chatId}`, {
                method: 'POST',
                body: formData,
            });
        })
        .then(response => response.json())
        .then(data => {
            if (data.ok) {
                alert('QR-код успешно отправлен в Telegram!'); // Уведомление об успешной отправке
            } else {
                alert('Ошибка при отправке QR-кода: ' + data.description);
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            alert('Ошибка при отправке QR-кода: ' + error.message);
        });
}



document.getElementById('send-btn').addEventListener('click', function () {
    const canvas = document.getElementById('qrcode-canvas');
    const dataURL = canvas.toDataURL('image/jpeg'); // Получаем изображение в формате JPEG

    // Отправляем изображение в Telegram-бота
    sendImageToTelegram(dataURL);
});