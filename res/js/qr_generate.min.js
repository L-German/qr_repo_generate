function generateKey() {
    const key = CryptoJS.lib.WordArray.random(32).toString(CryptoJS.enc.Hex);
    document.getElementById("encryption-key").value = key;
    return key;
}


function encryptText(text, key) {
    return CryptoJS.AES.encrypt(text, key).toString();
}


function decryptText(ciphertext, key) {
    try {
        const bytes = CryptoJS.AES.decrypt(ciphertext, key);
        return bytes.toString(CryptoJS.enc.Utf8);
    } catch (e) {
        return null; // Если ключ неверный
    }
}

function copyKey() {
    const keyInput = document.getElementById("encryption-key");
    keyInput.select();
    document.execCommand("copy");
    alert("Ключ скопирован!");
}

let app1;
!(function (e) {
    function generateQRCode() {
        
        const isEncryptionEnabled = document.getElementById("encrypt-toggle").checked;
        let inputText = document.getElementById("input-text").value;

        if (isEncryptionEnabled) {
            const encryptionKey = generateKey();
            inputText = encryptText(inputText, encryptionKey);
            document.getElementById("encryption-key-row").style.display = "table-row";
        } else {
            document.getElementById("encryption-key-row").style.display = "none";
        }

        const qrCanvas = document.getElementById("qrcode-canvas");
        qrCanvas.style.display = "none";
        
        const errorCorrectionLevel = document.getElementById("errcorlvl-medium").checked
            ? qrcodegen.QrCode.Ecc.MEDIUM
            : document.getElementById("errcorlvl-quartile").checked
                ? qrcodegen.QrCode.Ecc.QUARTILE
                : document.getElementById("errcorlvl-high").checked
                    ? qrcodegen.QrCode.Ecc.HIGH
                    : qrcodegen.QrCode.Ecc.LOW;


        const qrSegments = qrcodegen.QrSegment.makeSegments(inputText);
        const minVersion = parseInt(document.getElementById("force-min-version").value, 10);
        const maskPattern = parseInt(document.getElementById("force-mask-pattern").value, 10);
        const qrSize = document.getElementById("force-size").value;
       
        const qrCode = qrcodegen.QrCode.encodeSegments(qrSegments, errorCorrectionLevel, minVersion, 40, maskPattern, 0);
        const lightColor = document.getElementById("light-color-input").value;
        const darkColor = document.getElementById("dark-color-input").value;
        const gradientEndColor = document.getElementById("s_light-color-input").value;

        {
            let moduleSize = qrSize;

            (function (qrCode, moduleSize, border, lightColor, darkColor, gradientEndColor, canvas)  {
                if (moduleSize <= 0 || border < 0) throw new RangeError("Value out of range");
                const canvasSize = (qrCode.size + 2 * border) * moduleSize;
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const scale = 4;
                canvas.width = canvasSize * scale;
                canvas.height = canvasSize * scale;
                canvas.style.width = canvasSize + "px";
                canvas.style.height = canvasSize + "px";

                const ctx = canvas.getContext("2d");
                ctx.scale(scale, scale);
                const imageInput = document.getElementById("qr-image-input");
                const shouldRemoveBackground = document.getElementById("remove-background").checked;

                const centerImageSize = Math.floor(canvasSize / 3);
                const centerX = (canvasSize - centerImageSize) / 2;
                const centerY = (canvasSize - centerImageSize) / 2;

                // Создаем градиент
                const gradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
                gradient.addColorStop(0, darkColor);
                gradient.addColorStop(1, gradientEndColor);

                const moduleStyle = document.getElementById('module-style').value;

    // Функция для рисования разных форм
    function drawModule(ctx, x, y, size, style) {
        ctx.beginPath();
        switch(style) {
            case 'circle':
                ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI*2);
                break;
            
            
            default: // square
                ctx.rect(x, y, size, size);
        }
        ctx.fill();
    }

                // Рисуем QR-код
                for (let y = -border; y < qrCode.size + border; y++) {
                    for (let x = -border; x < qrCode.size + border; x++) {
                        const moduleX = (x + border) * moduleSize;
                        const moduleY = (y + border) * moduleSize;
            
                        ctx.fillStyle = qrCode.getModule(x, y) ? gradient : lightColor;
                        drawModule(ctx, moduleX, moduleY, moduleSize, moduleStyle);
                    }
                }

                if (shouldRemoveBackground && imageInput.files.length > 0) {
                    const bgImage = new Image();
                    bgImage.src = "res/picture/backgroung.png";
                    bgImage.onload = function () {
                        ctx.drawImage(bgImage, centerX, centerY, centerImageSize, centerImageSize);

                        if (imageInput.files.length > 0) {
                            const centerImage = new Image();
                            centerImage.src = URL.createObjectURL(imageInput.files[0]);
                            centerImage.onload = function () {
                                ctx.drawImage(centerImage, centerX, centerY, centerImageSize, centerImageSize);
                            };
                        }
                    };
                } else if (imageInput.files.length > 0) {
                    const centerImage = new Image();
                    centerImage.src = URL.createObjectURL(imageInput.files[0]);
                    centerImage.onload = function () {
                        ctx.drawImage(centerImage, centerX, centerY, centerImageSize, centerImageSize);
                    };
                }
            })(qrCode, moduleSize, 2, lightColor, darkColor, gradientEndColor, qrCanvas);

            qrCanvas.style.removeProperty("display");
        }
    }

    function getElementById(id) {
        const element = document.getElementById(id);
        if (element instanceof HTMLElement) return element;
    }

    function getInputElementById(id) {
        const element = getElementById(id);
        if (element instanceof HTMLInputElement) return element;
    }

    // Привязываем генерацию QR-кода к кнопке
    document.getElementById("generateButton").addEventListener("click", function (e) {
        e.preventDefault();
        generateQRCode();
    });


    ((app1 || (app1 = {})).handleVersionMinMax = function (e) {
        const n = o("force-min-version");
        let r = parseInt(n.value, 10),
            c = parseInt((40).value, 10);
        (r = Math.max(
            Math.min(r, qrcodegen.QrCode.MAX_VERSION),
            qrcodegen.QrCode.MIN_VERSION
        )),
            (c = Math.max(
                Math.min(c, qrcodegen.QrCode.MAX_VERSION),
                qrcodegen.QrCode.MIN_VERSION
            )),
            "min" == e && r > c ? (c = r) : "max" == e && c < r && (r = c),
            (n.value = r.toString()),
            c.toString(),
            t();
    }),
    (function initEventListeners() {
        // Синхронизация ползунков и числовых полей
        const minVersionInput = document.getElementById("force-min-version");
        const maskPatternInput = document.getElementById("force-mask-pattern");
        const sizeInput = document.getElementById("force-size");
        const minVersionRange = document.getElementById("customRange3");
        const maskPatternRange = document.getElementById("customRange4");
        const sizeRange = document.getElementById("customRange5");
    
        // Функции синхронизации
        function handleRangeInput(e) {
            const target = e.target;
            if (target === minVersionRange) minVersionInput.value = target.value;
            else if (target === maskPatternRange) maskPatternInput.value = target.value;
            else if (target === sizeRange) sizeInput.value = target.value;
        }
    
        function handleNumberInput(e) {
            const target = e.target;
            if (target === minVersionInput) minVersionRange.value = target.value;
            else if (target === maskPatternInput) maskPatternRange.value = target.value;
            else if (target === sizeInput) sizeRange.value = target.value;
        }
    
        // Вешаем обработчики синхронизации
        minVersionRange.addEventListener("input", handleRangeInput);
        maskPatternRange.addEventListener("input", handleRangeInput);
        sizeRange.addEventListener("input", handleRangeInput);
        
        minVersionInput.addEventListener("input", handleNumberInput);
        maskPatternInput.addEventListener("input", handleNumberInput);
        sizeInput.addEventListener("input", handleNumberInput);
    
        // Автоматическое обновление для всех полей, кроме size и version
        const autoUpdateInputs = [
            'input-text', 'errcorlvl-low', 'errcorlvl-medium', 
            'errcorlvl-quartile', 'errcorlvl-high', 'force-mask-pattern',
            'flexSwitchCheckDefault1', 'light-color-input', 'dark-color-input',
            's_light-color-input', 'remove-background', 'module-style'
        ];
    
        autoUpdateInputs.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('input', generateQRCode);
                element.addEventListener('change', generateQRCode);
            }
        });
    
        // Обработчик для кнопки (включает обновление size и version)
        document.getElementById("generateButton").addEventListener("click", function(e) {
            e.preventDefault();
            generateQRCode();
        });
    
        // Первоначальная генерация
        generateQRCode();
    })();
})();



function getChatId() {
    // Получаем данные пользователя
    const initData = new URLSearchParams(Telegram.WebApp.initData);

    // Извлекаем user.id
    const user = JSON.parse(initData.get('user'));
    return user?.id;
}


function sendImageToTelegram(dataURL) {
    const token = '7650373965:AAFUdBo-eMpIVIn_wXngV7TUs7lWtt1Lqq8';
    const chatId = getChatId();

    if (!chatId) {
        //alert('Ошибка: не удалось получить chat_id пользователя.');
        const canvas = document.getElementById('qrcode-canvas');
        const dataURL = canvas.toDataURL('image/png');

        // Создаем временную ссылку
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = document.getElementById('input-text').value + '.png'; // Имя файла при скачивании

        // Программно кликаем по ссылке, чтобы инициировать скачивание
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link); // Удаляем ссылку после скачивания
        return;
    }

    // Преобразуем data URL в Blob
    fetch(dataURL)
        .then(res => res.blob())
        .then(blob => {
            const formData = new FormData();
            formData.append('photo', blob, 'qr_code.jpg');

            return fetch(`https://api.telegram.org/bot${token}/sendPhoto?chat_id=${chatId}`, {
                method: 'POST',
                body: formData,
            });
        })
        .then(response => response.json())
        .then(data => {
            if (data.ok) {
                alert('QR-код успешно отправлен в Telegram!'); // Уведомление об успешной отправке
            } else {
                alert('Ошибка при отправке QR-кода: ' + data.description);
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            alert('Ошибка при отправке QR-кода: ' + error.message);
        });
}



document.getElementById('send-btn').addEventListener('click', function () {
    const canvas = document.getElementById('qrcode-canvas');
    const dataURL = canvas.toDataURL('image/jpeg'); // Получаем изображение в формате JPEG

    // Отправляем изображение в Telegram-бота
    sendImageToTelegram(dataURL);
});

async function hideQRInImage() {
    const stegoFile = document.getElementById('stego-image-input').files[0];
    if (!stegoFile) return alert('Загрузите изображение-контейнер');
    
    const qrCanvas = document.getElementById('qrcode-canvas');
    const stegoImage = await createImageBitmap(stegoFile);
    
    // Проверка размера
    if (stegoImage.width < qrCanvas.width || stegoImage.height < qrCanvas.height) {
        alert('Контейнер должен быть больше QR-кода!');
        return;
    }

    // Подготовка данных QR
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = qrCanvas.width;
    tempCanvas.height = qrCanvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(qrCanvas, 0, 0);
    const qrData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const qrBits = [];
    for (let i = 0; i < qrData.data.length; i += 4) {
        qrBits.push(qrData.data[i] < 128 ? 1 : 0);
    }
    
    // Кодирование размера QR в первых 32 битах
    const sizeBits = [];
    const qrSize = qrCanvas.width;
    for (let i = 0; i < 32; i++) {
        sizeBits.push((qrSize >> i) & 1);
    }

    // Создание стего-канваса
    const stegoCanvas = document.createElement('canvas');
    stegoCanvas.width = stegoImage.width;
    stegoCanvas.height = stegoImage.height;
    const ctx = stegoCanvas.getContext('2d');
    ctx.drawImage(stegoImage, 0, 0);

    const stegoData = ctx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
    let bitIndex = 0;

    // Встраивание размера
    for (let i = 0; i < 128; i += 4) { // Первые 32 пикселя (32 бита)
        stegoData.data[i + 2] = (stegoData.data[i + 2] & 0xFE) | sizeBits[bitIndex];
        bitIndex++;
        if (bitIndex >= 32) break;
    }

    // Встраивание данных QR
    bitIndex = 0;
    for (let i = 128; i < stegoData.data.length; i += 4) {
        if (bitIndex >= qrBits.length) break;
        stegoData.data[i + 2] = (stegoData.data[i + 2] & 0xFE) | qrBits[bitIndex];
        bitIndex++;
    }

    ctx.putImageData(stegoData, 0, 0);
    
    // Сохранение
    const link = document.createElement('a');
    link.download = 'image-output.png';
    link.href = stegoCanvas.toDataURL();
    link.click();
    document.getElementById('stego-status').textContent = 'QR успешно скрыт!';
}

async function extractQRFromImage() {
    const stegoFile = document.getElementById('stego-image-input').files[0];
    if (!stegoFile) return alert('Загрузите изображение, в котором спрятан QR-код');
    
    const stegoImage = await createImageBitmap(stegoFile);
    const stegoCanvas = document.createElement('canvas');
    stegoCanvas.width = stegoImage.width;
    stegoCanvas.height = stegoImage.height;
    const ctx = stegoCanvas.getContext('2d');
    ctx.drawImage(stegoImage, 0, 0);
    
    // Извлечение размера QR
    const stegoData = ctx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
    let qrSize = 0;
    for (let i = 0; i < 128; i += 4) {
        const bit = stegoData.data[i + 2] & 1;
        qrSize |= (bit << (Math.floor(i / 4)));
    }

    // Проверка размера
    if (qrSize < 10 || qrSize > 1000) {
        document.getElementById('stego-status').textContent = 'QR-код не найден';
        return;
    }

    // Извлечение данных
    const totalBits = qrSize * qrSize;
    const qrBits = [];
    for (let i = 128; i < stegoData.data.length; i += 4) {
        qrBits.push(stegoData.data[i + 2] & 1);
        if (qrBits.length >= totalBits) break;
    }

    // Восстановление QR
    const qrCanvas = document.getElementById('qrcode-canvas');
    qrCanvas.width = qrSize;
    qrCanvas.height = qrSize;
    const qrCtx = qrCanvas.getContext('2d');
    const qrImageData = qrCtx.createImageData(qrSize, qrSize);
    
    for (let i = 0; i < qrBits.length; i++) {
        const val = qrBits[i] * 255;
        const idx = i * 4;
        qrImageData.data[idx] = val;
        qrImageData.data[idx + 1] = val;
        qrImageData.data[idx + 2] = val;
        qrImageData.data[idx + 3] = 255;
    }
    
    qrCtx.putImageData(qrImageData, 0, 0);
    qrCanvas.style.display = 'block';
    document.getElementById('stego-status').textContent = 'QR успешно извлечен!';
}
