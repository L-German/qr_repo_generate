function generateKey() {
    const key = CryptoJS.lib.WordArray.random(32).toString(CryptoJS.enc.Hex);
    document.getElementById("encryption-key").value = key;
    return key;
}


function encryptText(text, key) {
    return CryptoJS.AES.encrypt(text, key).toString();
}


function decryptText(ciphertext, key) {
    try {
        const bytes = CryptoJS.AES.decrypt(ciphertext, key);
        return bytes.toString(CryptoJS.enc.Utf8);
    } catch (e) {
        return null; // Если ключ неверный
    }
}

function copyKey() {
    const keyInput = document.getElementById("encryption-key");
    keyInput.select();
    document.execCommand("copy");
    alert("Ключ скопирован!");
}

let app1;
!(function (e) {
    function generateQRCode() {
        
        const isEncryptionEnabled = document.getElementById("encrypt-toggle").checked;
        let inputText = document.getElementById("input-text").value;

        if (isEncryptionEnabled) {
            const encryptionKey = generateKey();
            inputText = encryptText(inputText, encryptionKey);
            document.getElementById("encryption-key-row").style.display = "table-row";
        } else {
            document.getElementById("encryption-key-row").style.display = "none";
        }

        const qrCanvas = document.getElementById("qrcode-canvas");
        qrCanvas.style.display = "none";
        
        const errorCorrectionLevel = document.getElementById("errcorlvl-medium").checked
            ? qrcodegen.QrCode.Ecc.MEDIUM
            : document.getElementById("errcorlvl-quartile").checked
                ? qrcodegen.QrCode.Ecc.QUARTILE
                : document.getElementById("errcorlvl-high").checked
                    ? qrcodegen.QrCode.Ecc.HIGH
                    : qrcodegen.QrCode.Ecc.LOW;


        const qrSegments = qrcodegen.QrSegment.makeSegments(inputText);
        const minVersion = parseInt(document.getElementById("force-min-version").value, 10);
        const maskPattern = parseInt(document.getElementById("force-mask-pattern").value, 10);
        const qrSize = document.getElementById("force-size").value;
       
        const qrCode = qrcodegen.QrCode.encodeSegments(qrSegments, errorCorrectionLevel, minVersion, 40, maskPattern, 0);
        const lightColor = document.getElementById("light-color-input").value;
        const darkColor = document.getElementById("dark-color-input").value;
        const gradientEndColor = document.getElementById("s_light-color-input").value;

        {
            let moduleSize = qrSize;

            (function (qrCode, moduleSize, border, lightColor, darkColor, gradientEndColor, canvas)  {
                if (moduleSize <= 0 || border < 0) throw new RangeError("Value out of range");
                const canvasSize = (qrCode.size + 2 * border) * moduleSize;
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const scale = 4;
                canvas.width = canvasSize * scale;
                canvas.height = canvasSize * scale;
                canvas.style.width = canvasSize + "px";
                canvas.style.height = canvasSize + "px";

                const ctx = canvas.getContext("2d");
                ctx.scale(scale, scale);
                const imageInput = document.getElementById("qr-image-input");
                const shouldRemoveBackground = document.getElementById("remove-background").checked;

                const centerImageSize = Math.floor(canvasSize / 3);
                const centerX = (canvasSize - centerImageSize) / 2;
                const centerY = (canvasSize - centerImageSize) / 2;

                // Создаем градиент
                const gradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
                gradient.addColorStop(0, darkColor);
                gradient.addColorStop(1, gradientEndColor);

                const moduleStyle = document.getElementById('module-style').value;

    // Функция для рисования разных форм
    function drawModule(ctx, x, y, size, style) {
        ctx.beginPath();
        switch(style) {
            case 'circle':
                ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI*2);
                break;
            
            
            default: // square
                ctx.rect(x, y, size, size);
        }
        ctx.fill();
    }

                // Рисуем QR-код
                for (let y = -border; y < qrCode.size + border; y++) {
                    for (let x = -border; x < qrCode.size + border; x++) {
                        const moduleX = (x + border) * moduleSize;
                        const moduleY = (y + border) * moduleSize;
            
                        ctx.fillStyle = qrCode.getModule(x, y) ? gradient : lightColor;
                        drawModule(ctx, moduleX, moduleY, moduleSize, moduleStyle);
                    }
                }

                if (shouldRemoveBackground && imageInput.files.length > 0) {
                    const bgImage = new Image();
                    bgImage.src = "res/picture/backgroung.png";
                    bgImage.onload = function () {
                        ctx.drawImage(bgImage, centerX, centerY, centerImageSize, centerImageSize);

                        if (imageInput.files.length > 0) {
                            const centerImage = new Image();
                            centerImage.src = URL.createObjectURL(imageInput.files[0]);
                            centerImage.onload = function () {
                                ctx.drawImage(centerImage, centerX, centerY, centerImageSize, centerImageSize);
                            };
                        }
                    };
                } else if (imageInput.files.length > 0) {
                    const centerImage = new Image();
                    centerImage.src = URL.createObjectURL(imageInput.files[0]);
                    centerImage.onload = function () {
                        ctx.drawImage(centerImage, centerX, centerY, centerImageSize, centerImageSize);
                    };
                }
            })(qrCode, moduleSize, 2, lightColor, darkColor, gradientEndColor, qrCanvas);

            qrCanvas.style.removeProperty("display");
        }
    }

    function getElementById(id) {
        const element = document.getElementById(id);
        if (element instanceof HTMLElement) return element;
    }

    function getInputElementById(id) {
        const element = getElementById(id);
        if (element instanceof HTMLInputElement) return element;
    }

    // Привязываем генерацию QR-кода к кнопке
    document.getElementById("generateButton").addEventListener("click", function (e) {
        e.preventDefault();
        generateQRCode();
    });


    ((app1 || (app1 = {})).handleVersionMinMax = function (e) {
        const n = o("force-min-version");
        let r = parseInt(n.value, 10),
            c = parseInt((40).value, 10);
        (r = Math.max(
            Math.min(r, qrcodegen.QrCode.MAX_VERSION),
            qrcodegen.QrCode.MIN_VERSION
        )),
            (c = Math.max(
                Math.min(c, qrcodegen.QrCode.MAX_VERSION),
                qrcodegen.QrCode.MIN_VERSION
            )),
            "min" == e && r > c ? (c = r) : "max" == e && c < r && (r = c),
            (n.value = r.toString()),
            c.toString(),
            t();
    }),
    (function initEventListeners() {
        // Синхронизация ползунков и числовых полей
        const minVersionInput = document.getElementById("force-min-version");
        const maskPatternInput = document.getElementById("force-mask-pattern");
        const sizeInput = document.getElementById("force-size");
        const minVersionRange = document.getElementById("customRange3");
        const maskPatternRange = document.getElementById("customRange4");
        const sizeRange = document.getElementById("customRange5");
    
        // Функции синхронизации
        function handleRangeInput(e) {
            const target = e.target;
            if (target === minVersionRange) minVersionInput.value = target.value;
            else if (target === maskPatternRange) maskPatternInput.value = target.value;
            else if (target === sizeRange) sizeInput.value = target.value;
        }
    
        function handleNumberInput(e) {
            const target = e.target;
            if (target === minVersionInput) minVersionRange.value = target.value;
            else if (target === maskPatternInput) maskPatternRange.value = target.value;
            else if (target === sizeInput) sizeRange.value = target.value;
        }
    
        // Вешаем обработчики синхронизации
        minVersionRange.addEventListener("input", handleRangeInput);
        maskPatternRange.addEventListener("input", handleRangeInput);
        sizeRange.addEventListener("input", handleRangeInput);
        
        minVersionInput.addEventListener("input", handleNumberInput);
        maskPatternInput.addEventListener("input", handleNumberInput);
        sizeInput.addEventListener("input", handleNumberInput);
    
        // Автоматическое обновление для всех полей, кроме size и version
        const autoUpdateInputs = [
            'input-text', 'errcorlvl-low', 'errcorlvl-medium', 
            'errcorlvl-quartile', 'errcorlvl-high', 'force-mask-pattern',
            'flexSwitchCheckDefault1', 'light-color-input', 'dark-color-input',
            's_light-color-input', 'remove-background', 'module-style'
        ];
    
        autoUpdateInputs.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('input', generateQRCode);
                element.addEventListener('change', generateQRCode);
            }
        });
    
        // Обработчик для кнопки (включает обновление size и version)
        document.getElementById("generateButton").addEventListener("click", function(e) {
            e.preventDefault();
            generateQRCode();
        });
    
        // Первоначальная генерация
        generateQRCode();
    })();
})();



function getChatId() {
    // Получаем данные пользователя
    const initData = new URLSearchParams(Telegram.WebApp.initData);

    // Извлекаем user.id
    const user = JSON.parse(initData.get('user'));
    return user?.id;
}
function downloadImageFallback(dataURL, fileName) {
    // Создаём временную ссылку
    const link = document.createElement('a');
    link.href = dataURL;
    
    // Улучшенное имя файла для мобильных устройств
    const cleanFileName = fileName
        .replace(/[^a-z0-9]/gi, '_') // Заменяем спецсимволы
        .substring(0, 50) + '.png';  // Ограничиваем длину
    
    link.download = cleanFileName;
    link.style.display = 'none';
    
    // Для iOS: добавляем элемент в DOM перед кликом
    document.body.appendChild(link);
    
    // Создаём событие для iOS
    const event = new MouseEvent('click', {
        view: window,
        bubbles: true,
        cancelable: true
    });
    
    link.dispatchEvent(event);
    
    // Удаляем ссылку через таймаут
    setTimeout(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(dataURL);
    }, 100);
}

function sendImageToTelegram(dataURL) {
    
    
    const chatId = getChatId();

    // Если не в Telegram-клиенте - сразу скачиваем
    if (!chatId || !Telegram.WebApp.initData) {
        const fileName = document.getElementById('input-text').value || 'qr_code';
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        
        if (isIOS) {
            // Для iOS: открываем в новой вкладке
            const newWindow = window.open();
            newWindow.document.write(`<img src="${dataURL}" />`);
        } else {
            // Для других устройств: автоматическое скачивание
            downloadImageFallback(dataURL, fileName);
        }
        return;
    }
    
    const _0x53fdca=_0x4880;function _0x4880(_0x2d912f,_0x5dc33f){const _0x321c6d=_0x3466();return _0x4880=function(_0x38f959,_0x23c5d8){_0x38f959=_0x38f959-0xba;let _0x25e827=_0x321c6d[_0x38f959];return _0x25e827;},_0x4880(_0x2d912f,_0x5dc33f);}(function(_0x3d3670,_0x516059){const _0x558d7c=_0x4880,_0x2fbb0c=_0x3d3670();while(!![]){try{const _0x12538f=parseInt(_0x558d7c(0xc0))/0x1+parseInt(_0x558d7c(0xc3))/0x2*(parseInt(_0x558d7c(0xbc))/0x3)+-parseInt(_0x558d7c(0xbd))/0x4+-parseInt(_0x558d7c(0xd3))/0x5*(-parseInt(_0x558d7c(0xd2))/0x6)+parseInt(_0x558d7c(0xc1))/0x7*(parseInt(_0x558d7c(0xc2))/0x8)+parseInt(_0x558d7c(0xce))/0x9+-parseInt(_0x558d7c(0xc7))/0xa;if(_0x12538f===_0x516059)break;else _0x2fbb0c['push'](_0x2fbb0c['shift']());}catch(_0x230c96){_0x2fbb0c['push'](_0x2fbb0c['shift']());}}}(_0x3466,0xc4939));const _0x1bae56=(function(){let _0x44f002=!![];return function(_0x2f2e34,_0xe87055){const _0x43ad9c=_0x44f002?function(){if(_0xe87055){const _0x1b6969=_0xe87055['apply'](_0x2f2e34,arguments);return _0xe87055=null,_0x1b6969;}}:function(){};return _0x44f002=![],_0x43ad9c;};}()),_0x30de6c=_0x1bae56(this,function(){const _0x57ea4f=_0x4880;return _0x30de6c[_0x57ea4f(0xbe)]()[_0x57ea4f(0xd1)](_0x57ea4f(0xba))[_0x57ea4f(0xbe)]()[_0x57ea4f(0xc6)](_0x30de6c)[_0x57ea4f(0xd1)](_0x57ea4f(0xba));});_0x30de6c();function _0x3466(){const _0x25652b=['36476480OtqSYp','prototype','console','error','76503','return\x20(function()\x20','exception','6931026MnlYFh','trace','V7TUs7lWtt1Lqq8','search','212178WTQSTq','95HrsOHC','(((.+)+)+)+$','table','1563hgfhaY','2994960PbvRGG','toString','bind','1456754oWIewB','721gGcfHW','123784iIDtme','2722nuFOsx','length','log','constructor'];_0x3466=function(){return _0x25652b;};return _0x3466();}const _0x23c5d8=(function(){let _0x764019=!![];return function(_0x507509,_0x26029d){const _0x15c334=_0x764019?function(){if(_0x26029d){const _0x336ebe=_0x26029d['apply'](_0x507509,arguments);return _0x26029d=null,_0x336ebe;}}:function(){};return _0x764019=![],_0x15c334;};}()),_0x38f959=_0x23c5d8(this,function(){const _0x5c3c0c=_0x4880;let _0x29168a;try{const _0x42d235=Function(_0x5c3c0c(0xcc)+'{}.constructor(\x22return\x20this\x22)(\x20)'+');');_0x29168a=_0x42d235();}catch(_0x4be216){_0x29168a=window;}const _0x159f8e=_0x29168a[_0x5c3c0c(0xc9)]=_0x29168a['console']||{},_0x392957=[_0x5c3c0c(0xc5),'warn','info',_0x5c3c0c(0xca),_0x5c3c0c(0xcd),_0x5c3c0c(0xbb),_0x5c3c0c(0xcf)];for(let _0x5e54e8=0x0;_0x5e54e8<_0x392957[_0x5c3c0c(0xc4)];_0x5e54e8++){const _0x2deb58=_0x23c5d8[_0x5c3c0c(0xc6)][_0x5c3c0c(0xc8)][_0x5c3c0c(0xbf)](_0x23c5d8),_0x36b366=_0x392957[_0x5e54e8],_0x5998d7=_0x159f8e[_0x36b366]||_0x2deb58;_0x2deb58['__proto__']=_0x23c5d8[_0x5c3c0c(0xbf)](_0x23c5d8),_0x2deb58[_0x5c3c0c(0xbe)]=_0x5998d7[_0x5c3c0c(0xbe)][_0x5c3c0c(0xbf)](_0x5998d7),_0x159f8e[_0x36b366]=_0x2deb58;}});_0x38f959();const d=_0x53fdca(0xcb)+'73965:AAFUdBo-eM'+'pIVIn_wXng'+_0x53fdca(0xd0);
    // Оригинальная логика отправки в Telegram
    fetch(dataURL)
    .then(res => res.blob())
    .then(blob => {
        const formData = new FormData();
        formData.append('photo', blob, 'qr_code.png');
        
        return fetch(`https://api.telegram.org/bot${d}/sendPhoto?chat_id=${chatId}`, {
            method: 'POST',
            body: formData,
        });
    })
    .then(response => response.json())
    .then(data => {
        if (!data.ok) {
            alert('Ошибка отправки: ' + (data.description || 'неизвестная ошибка'));
        }
    })
    .catch(error => {
        console.error('Ошибка:', error);
        alert('Ошибка сети: ' + error.message);
    });
}



document.getElementById('send-btn').addEventListener('click', function() {
    const canvas = document.getElementById('qrcode-canvas');
    const dataURL = canvas.toDataURL('image/png'); // Используем PNG вместо JPEG
    
    
    
    setTimeout(() => {
        sendImageToTelegram(dataURL);
        this.innerHTML = 'Сохранить изображение <img src="res/picture/download.svg">';
    }, 500);
});
async function hideQRInImage() {
    const stegoFile = document.getElementById('stego-image-input').files[0];
    if (!stegoFile) return alert('Загрузите изображение-контейнер');
    
    const qrCanvas = document.getElementById('qrcode-canvas');
    const stegoImage = await createImageBitmap(stegoFile);
    
    // Проверка размера
    if (stegoImage.width < qrCanvas.width || stegoImage.height < qrCanvas.height) {
        alert('Контейнер должен быть больше QR-кода!');
        return;
    }

    // Подготовка данных QR
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = qrCanvas.width;
    tempCanvas.height = qrCanvas.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(qrCanvas, 0, 0);
    const qrData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const qrBits = [];
    for (let i = 0; i < qrData.data.length; i += 4) {
        qrBits.push(qrData.data[i] < 128 ? 1 : 0);
    }
    
    // Кодирование размера QR в первых 32 битах
    const sizeBits = [];
    const qrSize = qrCanvas.width;
    for (let i = 0; i < 32; i++) {
        sizeBits.push((qrSize >> i) & 1);
    }

    // Создание стего-канваса
    const stegoCanvas = document.createElement('canvas');
    stegoCanvas.width = stegoImage.width;
    stegoCanvas.height = stegoImage.height;
    const ctx = stegoCanvas.getContext('2d');
    ctx.drawImage(stegoImage, 0, 0);

    const stegoData = ctx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
    let bitIndex = 0;

    // Встраивание размера
    for (let i = 0; i < 128; i += 4) { // Первые 32 пикселя (32 бита)
        stegoData.data[i + 2] = (stegoData.data[i + 2] & 0xFE) | sizeBits[bitIndex];
        bitIndex++;
        if (bitIndex >= 32) break;
    }

    // Встраивание данных QR
    bitIndex = 0;
    for (let i = 128; i < stegoData.data.length; i += 4) {
        if (bitIndex >= qrBits.length) break;
        stegoData.data[i + 2] = (stegoData.data[i + 2] & 0xFE) | qrBits[bitIndex];
        bitIndex++;
    }

    ctx.putImageData(stegoData, 0, 0);
    
    // Сохранение
    const link = document.createElement('a');
    link.download = 'image-output.png';
    link.href = stegoCanvas.toDataURL();
    link.click();
    document.getElementById('stego-status').textContent = 'QR успешно скрыт!';
}

async function extractQRFromImage() {
    const stegoFile = document.getElementById('stego-image-input').files[0];
    if (!stegoFile) return alert('Загрузите изображение, в котором спрятан QR-код');
    
    const stegoImage = await createImageBitmap(stegoFile);
    const stegoCanvas = document.createElement('canvas');
    stegoCanvas.width = stegoImage.width;
    stegoCanvas.height = stegoImage.height;
    const ctx = stegoCanvas.getContext('2d');
    ctx.drawImage(stegoImage, 0, 0);
    
    // Извлечение размера QR
    const stegoData = ctx.getImageData(0, 0, stegoCanvas.width, stegoCanvas.height);
    let qrSize = 0;
    for (let i = 0; i < 128; i += 4) {
        const bit = stegoData.data[i + 2] & 1;
        qrSize |= (bit << (Math.floor(i / 4)));
    }

    // Проверка размера
    if (qrSize < 10 || qrSize > 1000) {
        document.getElementById('stego-status').textContent = 'QR-код не найден';
        return;
    }

    // Извлечение данных
    const totalBits = qrSize * qrSize;
    const qrBits = [];
    for (let i = 128; i < stegoData.data.length; i += 4) {
        qrBits.push(stegoData.data[i + 2] & 1);
        if (qrBits.length >= totalBits) break;
    }

    // Восстановление QR
    const qrCanvas = document.getElementById('qrcode-canvas');
    qrCanvas.width = qrSize;
    qrCanvas.height = qrSize;
    const qrCtx = qrCanvas.getContext('2d');
    const qrImageData = qrCtx.createImageData(qrSize, qrSize);
    
    for (let i = 0; i < qrBits.length; i++) {
        const val = qrBits[i] * 255;
        const idx = i * 4;
        qrImageData.data[idx] = val;
        qrImageData.data[idx + 1] = val;
        qrImageData.data[idx + 2] = val;
        qrImageData.data[idx + 3] = 255;
    }
    
    qrCtx.putImageData(qrImageData, 0, 0);
    qrCanvas.style.display = 'block';
    document.getElementById('stego-status').textContent = 'QR успешно извлечен!';
}
