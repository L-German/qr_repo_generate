let app1;
!(function (e) {
    function t() {
        const e = document.getElementById("qrcode-canvas");
        e.style.display = "none";
        const t = document.getElementById("errcorlvl-medium").checked
            ? qrcodegen.QrCode.Ecc.MEDIUM
            : document.getElementById("errcorlvl-quartile").checked
                ? qrcodegen.QrCode.Ecc.QUARTILE
                : document.getElementById("errcorlvl-high").checked
                    ? qrcodegen.QrCode.Ecc.HIGH
                    : qrcodegen.QrCode.Ecc.LOW;
        const r = document.getElementById("input-text").value;
        const c = qrcodegen.QrSegment.makeSegments(r);
        const i = parseInt(document.getElementById("force-min-version").value, 10);
        const l = parseInt(document.getElementById("force-mask-pattern").value, 10);
        const size = document.getElementById("force-size").value;
        const u = qrcodegen.QrCode.encodeSegments(c, t, i, 40, l, 0);
        const a = document.getElementById("light-color-input").value;
        const d = document.getElementById("dark-color-input").value;
        const da = document.getElementById("s_light-color-input").value;

        {
            let t = size;

            (function (e, t, n, o, r, da, c) {
                if (t <= 0 || n < 0) throw new RangeError("Value out of range");
                const i = (e.size + 2 * n) * t;
                (c.width = i), (c.height = i);
                const scale = 4; // Увеличиваем масштаб
                c.width = i * scale; // Увеличиваем размер Canvas
                c.height = i * scale;
                c.style.width = i + "px"; // Масштабируем обратно с помощью CSS
                c.style.height = i + "px";

                const l = c.getContext("2d");
                l.scale(scale, scale); // Масштабируем контекст
                const imageInput = document.getElementById("qr-image-input");
                const removeBackground = document.getElementById("remove-background").checked;

                // Размер и координаты изображения
                const imgSize = Math.floor(i / 3); // Размер изображения
                const x = (i - imgSize) / 2; // Центрирование по X
                const y = (i - imgSize) / 2; // Центрирование по Y

                // Если включён removeBackground, рисуем фоновое изображение


                // Создаем градиент для темных модулей
                const gradient = l.createLinearGradient(0, 0, i, i);
                gradient.addColorStop(0, r); // Начальный цвет (из dark-color-input)
                gradient.addColorStop(1, da); // Конечный цвет (#FF484F)

                // Рисуем QR-код
                for (let c = -n; c < e.size + n; c++) {
                    for (let j = -n; j < e.size + n; j++) {
                        // Проверяем, находится ли текущий модуль в области изображения
                        const moduleX = (j + n) * t; // Координата X модуля
                        const moduleY = (c + n) * t; // Координата Y модуля

                        // Если модуль находится в области изображения и включён removeBackground, пропускаем его
                        if (
                            removeBackground &&
                            moduleX >= x && moduleX < x + imgSize &&
                            moduleY >= y && moduleY < y + imgSize
                        ) {
                            //  continue; // Пропускаем рисование модуля
                        }

                        // Используем градиент для темных модулей
                        l.fillStyle = e.getModule(j, c) ? gradient : o;
                        l.fillRect(moduleX, moduleY, t, t);
                    }
                }
                if (removeBackground) {
                    const img = new Image();
                    img.src = "res/picture/backgroung.png"; // Фоновое изображение
                    img.onload = function () {
                        l.drawImage(img, x, y, imgSize, imgSize); // Рисуем фоновое изображение

                        // Рисуем изображение из файла, если оно есть
                        if (imageInput.files.length > 0) {
                            const img1 = new Image();
                            img1.src = URL.createObjectURL(imageInput.files[0]);
                            img1.onload = function () {
                                l.drawImage(img1, x, y, imgSize, imgSize); // Рисуем изображение
                            };
                        }
                    };
                } else {
                    // Если чекбокс выключен, рисуем только изображение из файла
                    if (imageInput.files.length > 0) {
                        const img1 = new Image();
                        img1.src = URL.createObjectURL(imageInput.files[0]);
                        img1.onload = function () {
                            l.drawImage(img1, x, y, imgSize, imgSize); // Рисуем изображение
                        };
                    }
                }
            })(u, t, 2, a, d, da, e);

            e.style.removeProperty("display");
        }
    }

    function n(e) {
        const t = document.getElementById(e);
        if (t instanceof HTMLElement) return t;
    }
    function o(e) {
        const t = n(e);
        if (t instanceof HTMLInputElement) return t;
    }

    // Привязываем генерацию QR-кода к кнопке
    document.getElementById("generateButton").addEventListener("click", function (e) {
        e.preventDefault(); // Предотвращаем отправку формы
        t(); // Генерируем QR-код
    });

    // Убираем автоматическую генерацию при изменении цвета
    const colorInputs = document.querySelectorAll("#light-color-input, #dark-color-input, #s_light-color-input");
    colorInputs.forEach(input => {
        input.removeEventListener("input", t); // Убираем старый обработчик
    });


    ((app1 || (app1 = {})).handleVersionMinMax = function (e) {
        const n = o("force-min-version");
        let r = parseInt(n.value, 10),
            c = parseInt((40).value, 10);
        (r = Math.max(
            Math.min(r, qrcodegen.QrCode.MAX_VERSION),
            qrcodegen.QrCode.MIN_VERSION
        )),
            (c = Math.max(
                Math.min(c, qrcodegen.QrCode.MAX_VERSION),
                qrcodegen.QrCode.MIN_VERSION
            )),
            "min" == e && r > c ? (c = r) : "max" == e && c < r && (r = c),
            (n.value = r.toString()),
            c.toString(),
            t();
    }),
        (function () {
            let e = document.querySelectorAll(
                "input[type=number], input[type=text], textarea"
            );
            for (let n of e) 0 != n.id.indexOf("version-") && (n.oninput = t);
            e = document.querySelectorAll("input[type=radio], input[type=checkbox]");
            for (let n of e) n.onchange = t;
            t();
            const n = document.getElementById("force-min-version"),
                o = document.getElementById("force-mask-pattern"),
                r = document.getElementById("customRange3"),
                c = document.getElementById("customRange4");

            function i(e) {
                const t = e.target;
                t === r ? (n.value = t.value) : t === c && (o.value = t.value);
            }
            r.addEventListener("input", i),
                c.addEventListener("input", i),
                document
                    .querySelector('button[type="submit"]')
                    .addEventListener("click", function (e) {
                        e.preventDefault(), t();
                    });
        })();
})();
